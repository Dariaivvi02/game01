import random
import pygame
import asyncio
import platform
import sys
import os

pygame.init()

# Настройки окна
WIDTH = 800
HEIGHT = 600
FPS = 60

# Размеры корзины, шарика и камня
BASKET_W = 100
BASKET_H = 20
BALL_R = 15
ROCK_R = 20

# Скорость объектов
BALL_SPEED = 2
ROCK_SPEED = 4

SPAWN_TIMER = 60  # как часто спавнятся объекты

# Цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (220, 50, 50)
BLUE = (50, 50, 220)
GREEN = (50, 220, 50)
GRAY = (100, 100, 100)
DARK_GRAY = (50, 50, 50)

# Шрифты
font = pygame.font.SysFont("Arial", 36)
small_font = pygame.font.SysFont("Arial", 24)

class Basket:
    def __init__(self):
        self.w = BASKET_W
        self.h = BASKET_H
        self.x = WIDTH // 2 - self.w // 2
        self.y = HEIGHT - 50
        self.speed = 7
        self.rect = pygame.Rect(self.x, self.y, self.w, self.h)

    def move(self, dir):
        if dir == "left":
            if self.x > 0:
                self.x -= self.speed
        elif dir == "right":
            if self.x < WIDTH - self.w:
                self.x += self.speed
        self.rect.topleft = (self.x, self.y)

    def draw(self, screen):
        pygame.draw.rect(screen, WHITE, self.rect, border_radius=10)

class Ball:
    def __init__(self):
        self.x = random.randint(BALL_R, WIDTH - BALL_R)
        self.y = -BALL_R
        self.r = BALL_R
        self.color = random.choice([RED, BLUE, GREEN])
        self.speed = BALL_SPEED
        self.rect = pygame.Rect(self.x - self.r, self.y - self.r, self.r * 2, self.r * 2)

    def move(self):
        self.y += self.speed
        self.rect.center = (self.x, self.y)

    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (self.x, self.y), self.r)

class Rock:
    def __init__(self):
        self.x = random.randint(ROCK_R, WIDTH - ROCK_R)
        self.y = -ROCK_R
        self.r = ROCK_R
        self.color = GRAY
        self.speed = ROCK_SPEED
        self.rect = pygame.Rect(self.x - self.r, self.y - self.r, self.r*2, self.r*2)

    def move(self):
        self.y += self.speed
        self.rect.center = (self.x, self.y)

    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (self.x, self.y), self.r)

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Ball Catcher")
        self.clock = pygame.time.Clock()
        self.state = "menu"
        self.basket = Basket()
        self.balls = []
        self.rocks = []
        self.score = 0
        self.lives = 3
        self.spawn_counter = 0
        self.high_score = self.get_high_score()
        self.paused = False

    def get_high_score(self):
        try:
            if os.path.exists("highscore.txt"):
                with open("highscore.txt", "r") as f:
                    return int(f.read())
        except:
            return 0
        return 0

    def save_high_score(self):
        with open("highscore.txt", "w") as f:
            f.write(str(self.high_score))

    def draw_button(self, text, x, y, w, h, color1, color2):
        pos = pygame.mouse.get_pos()
        click = pygame.mouse.get_pressed()
        rect = pygame.Rect(x, y, w, h)
        if rect.collidepoint(pos):
            pygame.draw.rect(self.screen, color2, rect, border_radius=10)
            if click[0] == 1:
                return True
        else:
            pygame.draw.rect(self.screen, color1, rect, border_radius=10)
        label = font.render(text, True, WHITE)
        self.screen.blit(label, (x + (w - label.get_width())//2, y + (h - label.get_height())//2))
        return False

    def show_menu(self):
        self.screen.fill(BLACK)
        title = font.render("Ball Catcher", True, WHITE)
        self.screen.blit(title, (WIDTH//2 - title.get_width()//2, 100))

        if self.draw_button("Start Game", WIDTH//2 - 100, 200, 200, 50, DARK_GRAY, GRAY):
            self.state = "playing"
            self.score = 0
            self.lives = 3
            self.balls = []
            self.rocks = []
        if self.draw_button("High Score", WIDTH//2 - 100, 300, 200, 50, DARK_GRAY, GRAY):
            self.state = "high_score"
        if self.draw_button("Exit", WIDTH//2 - 100, 400, 200, 50, DARK_GRAY, GRAY):
            self.save_high_score()
            pygame.quit()
            sys.exit()

    def show_high_score(self):
        self.screen.fill(BLACK)
        score_text = font.render("High Score: " + str(self.high_score), True, WHITE)
        self.screen.blit(score_text, (WIDTH//2 - score_text.get_width()//2, 200))
        if self.draw_button("Back", WIDTH//2 - 100, 400, 200, 50, DARK_GRAY, GRAY):
            self.state = "menu"

    def show_game_over(self):
        self.screen.fill(BLACK)
        go_text = font.render("Game Over", True, WHITE)
        sc_text = font.render("Your Score: " + str(self.score), True, WHITE)
        hi_text = font.render("High Score: " + str(self.high_score), True, WHITE)

        self.screen.blit(go_text, (WIDTH//2 - go_text.get_width()//2, 150))
        self.screen.blit(sc_text, (WIDTH//2 - sc_text.get_width()//2, 250))
        self.screen.blit(hi_text, (WIDTH//2 - hi_text.get_width()//2, 350))

        if self.draw_button("Back to Menu", WIDTH//2 - 100, 450, 200, 50, DARK_GRAY, GRAY):
            self.state = "menu"
        if self.draw_button("Play Again", WIDTH//2 - 100, 520, 200, 50, DARK_GRAY, GRAY):
            self.state = "playing"
            self.score = 0
            self.lives = 3
            self.balls = []
            self.rocks = []

    def draw_hud(self):
        sc = small_font.render("Score: " + str(self.score), True, WHITE)
        lv = small_font.render("Lives: " + str(self.lives), True, WHITE)
        self.screen.blit(sc, (10, 10))
        self.screen.blit(lv, (WIDTH - lv.get_width() - 10, 10))

    def spawn(self):
        self.spawn_counter += 1
        if self.spawn_counter % SPAWN_TIMER == 0:
            if random.random() < 0.7:
                self.balls.append(Ball())
            else:
                self.rocks.append(Rock())

    def check_collide(self):
        for ball in self.balls[:]:
            if self.basket.rect.colliderect(ball.rect):
                self.score += 10
                self.balls.remove(ball)
            elif ball.y > HEIGHT:
                self.balls.remove(ball)
                self.lives -= 1
                if self.lives <= 0:
                    if self.score > self.high_score:
                        self.high_score = self.score
                        self.save_high_score()
                    self.state = "game_over"

        for rock in self.rocks[:]:
            if self.basket.rect.colliderect(rock.rect):
                self.lives -= 1
                self.rocks.remove(rock)
                if self.lives <= 0:
                    if self.score > self.high_score:
                        self.high_score = self.score
                        self.save_high_score()
                    self.state = "game_over"
            elif rock.y > HEIGHT:
                self.rocks.remove(rock)

    async def main_loop(self):
        await asyncio.sleep(0)
        running = True

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.save_high_score()
                    running = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_p and self.state == "playing":
                        self.paused = not self.paused

            if self.state == "menu":
                self.show_menu()
            elif self.state == "high_score":
                self.show_high_score()
            elif self.state == "game_over":
                self.show_game_over()
            elif self.state == "playing" and not self.paused:
                keys = pygame.key.get_pressed()
                if keys[pygame.K_LEFT]:
                    self.basket.move("left")
                if keys[pygame.K_RIGHT]:
                    self.basket.move("right")

                self.spawn()
                for ball in self.balls:
                    ball.move()
                for rock in self.rocks:
                    rock.move()

                self.check_collide()
                self.screen.fill(BLACK)
                self.basket.draw(self.screen)
                for ball in self.balls:
                    ball.draw(self.screen)
                for rock in self.rocks:
                    rock.draw(self.screen)
                self.draw_hud()
            elif self.paused:
                pause_text = font.render("Paused", True, WHITE)
                self.screen.blit(pause_text, (WIDTH//2 - pause_text.get_width()//2, HEIGHT//2))

            pygame.display.flip()
            self.clock.tick(FPS)
            await asyncio.sleep(1.0 / FPS)

        pygame.quit()

def setup():
    global game
    game = Game()

async def main():
    setup()
    await game.main_loop()

if platform.system() == "Emscripten":
    asyncio.ensure_future(main())
else:
    if __name__ == "__main__":
        asyncio.run(main())
